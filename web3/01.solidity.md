

#### 1 Basics

1. Solidity小心引入允许复制、重用或资产丢失的bug，小心重入攻击（在Move上则不可能）
2. [panic via assert and error via require)](https://docs.soliditylang.org/en/develop/control-structures.html#panic-via-assert-and-error-via-require)
   1. assert = panic+内部代码+revert，一旦panic意味着代码需要fix
   2. require=error+外部代码+revert，是正常错误检查过程，require判断不过是正常的
   3. 如果失败了，require会退还剩余的gas，assert则消耗剩余的gas

3. function默认是public，而state默认是internal
   1. public的state自动生成一个getter()
   2. internal <=> 等价于c#的internal+protected

4. 引用类型：struct, array, mapping => 凡复合类型都是reference => 都需Data location: memory, storage, calldata
   1. memory: 内存变量，调用结束即释放
   2. storage: 存储state变量，生命周期同contract，生命特征类似于DB
   3. calldata: 函数参数，不可修改




#### 2 类型

modifier，类型后面

1. payable



```solidity
// address: 用于代表是某个用户
msg.sender.transfer(123);	// 无论是transfer()还是send()，接收钱的都是sender
address(this).send(123);	// transfer如果失败了会panic，但send如果失败了会返回false, transfer()=require(send())

// contract: 合约

// array: 应该是跟js的数组一样的
struct Proposal {
	bytes32 name;
	uint voteCount;
}

Proposal[] public items;
items.push(Proposal{ name: 0xdead, voteCount: 0});
items.length;

// mapping: 不是map哦
struct Voter {
	uint weight;
	bool voted;
}
mapping(address => Voter) private voters;
ovters[msg.sender].weight = 1;	// struct真的是struct，不需要使用new初始化或插入，直接用

// string
string memory name;

// uint: 所有的int类型都是无符号的
uint age;

```

