

#### 1 Basics

1. Solidity小心引入允许复制、重用或资产丢失的bug，小心重入攻击（在Move上则不可能）
2. payable：标记为payable的方法会把msg.value写到address(this).balance上
3. [panic via assert and error via require)](https://docs.soliditylang.org/en/develop/control-structures.html#panic-via-assert-and-error-via-require)
   1. assert = panic+内部代码+revert，一旦panic意味着代码需要fix
   2. require=error+外部代码+revert，是正常错误检查过程，require判断不过是正常的
   3. 如果失败了，require会退还剩余的gas，assert则消耗剩余的gas

4. function默认是public，而state默认是internal ⇒ 基本上意味着随便访问，state要好一点点儿
   1. public的state自动生成一个getter()
   2. internal ⇔ c#的internal+protected
   3. this.data()是外部访问

5. 引用类型：struct, array, mapping ⇒ 凡复合类型都是reference ⇒ 都需Data location: memory, storage, calldata
   1. memory: 内存变量，调用结束即释放
   2. storage: 存储state变量，生命周期同contract，生命特征类似于DB
   3. calldata: 函数参数，不可修改




#### 2 类型

```solidity
// address: 用于代表是某个用户
msg.sender.transfer(123);	// 无论是transfer()还是send()，接收钱的都是sender
address(this).send(123);	// transfer如果失败了会panic，但send如果失败了会返回false, transfer()=require(send())

// contract: 合约

// array: 应该是跟js的数组一样的
struct Proposal {
	bytes32 name;
	uint voteCount;
}

Proposal[] public items;
items.push(Proposal{ name: 0xdead, voteCount: 0});
items.length;

// mapping: 不是map哦
struct Voter {
	uint weight;
	bool voted;
}
mapping(address => Voter) private voters;
ovters[msg.sender].weight = 1;	// struct真的是struct，不需要使用new初始化或插入，直接用

// string
string memory name;

// uint: 所有的int类型都是无符号的
uint age;

```



#### 3 安全

1. 随机数： 调用off-chain的第三方服务，比如 Oraclize 来获取随机数
2. 外部访问：所有外部访问都应该被怀疑有安全性问题，比如`msg.sender.call{value: 12}("")`
3. 整数溢出：在solidity 0.8.0之后，内置整数溢出检查，基本上不再需要SafeMath库了。a>b不会溢出，但a+b会溢出
4. [重入漏洞](https://learnblockchain.cn/article/3278)：msg.sender.call()对gas没有限制，会调用fallback方法，非常容易被攻击
5. [自毁函数](https://www.8btc.com/media/6718858)：单独在合约中记一个balance变量，而不是通过`address(this).balance`来做计算，否则容易被selfdestruct攻击



```solidity
// https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard
// SPDX-License-Identifier: MIT

// 防重入锁, 示例代码如下
pragma solidity ^0.8.3;

contract ReEntrancyGuard {
    bool internal locked;

    modifier noReentrant() {
    		require(!locked, "No re-entrancy");
        locked = true;
        _; 
        locked = false;
    }
}
```



