

#### 1 Basics



#### 2 AnimationClip

##### 01 Basics

1. 外部导入, 或在unity3d中制作
2. **cmd+6**: 打开animation窗口录制动画, 新建动画会得到anim, controller, animator这一个完整的资源
3.  unity3d中的很多资源文件都是yaml文件, 含: unity, prefab, anim, controller等
4. .anim文件中的每一个curve字段中会**存储path信息**, 如果path匹配不上则无法控制对应的骨骼



##### 02 设置

1. Loop Time: 勾选 → 循环播放, 对于walk, run之类的动画是必选的



#### 3 Animator组件

##### 01 Basics



##### 02 设置

1. Controller: 挂载动画状态机(AnimatorController)
2. Avatar: 使用Humanoid动画时, 在这里挂载**自己创建的Avatar**. 同时只要Model位于Animator的子节点中即可, 对多少层无要求
3. Apply Root Motion: 使用**动画位移**, 而不是script控制位移(in place动画)
4. Update Mode更新模式:
   1. Normal: 与Update帧率同步
   2. Animate Physics: 与Fixed Update帧率同步, 动画在物理交互时启用
   3. Unscaled Time: 忽略timeScale设置, 动画不会随timeScale设置变快或变慢
5. Culing Mode剔除模式:
   1. Always Animate: 在camera看不见时也不剔除
   2. Cull Update Transforms: 在camera看不见时**剔除IK**
   3. Cull Completely: 在camera看不见时停止动画



```c#

private void Start()
{
	var indexIndex = animator.GetLayoutIndex("Base Layer");
	animator.SetLayerWeight(layerIndex, 1); 
  var stateInfo = animator.GetCurrentAnimatorStateInfo(layerIndex);
}

// OnAnimatorMove()隶属physics逻辑, 可从root motion抢夺player控制权.
private void OnAnimatorMove()
{
  // script出现OnAnimatorMove(), 物体就由script而不是root motion控制移动了
  // 如果想应用root motion的效果, 可以自己调用ApplyBuiltinRootMotion(), 然后再微调transform的位置
  animator.ApplyBuiltinRootMotion();
  
  // characterController.Move(animator.deltaPosition); // Move()方法需要自己写gravity逻辑
  characterController.SimpleMove(animator.velocity);	 // SimpleMove()方法自带gravity逻辑
  
  // 人类最早的hash算法应该是按手印, 通过是 斗 or 簸箕 来验证是不是同一个人
  var speedHash = Animator.StringToHash("Speed");
  animator.SetFloat(speedHash, speed);
}

```





#### 4 AnimatorController状态机

##### 01 Basics

1. **有限状态机**: 

   1. 10个以内clip文件可以考虑手建状态机
   2. 如果clip太多的话建议使用[AnimatorOverrideController](https://docs.unity.cn/cn/current/ScriptReference/AnimatorOverrideController.ApplyOverrides.html)动态加载clip, 然后直接使用`animator.Play("name");`播放

2. 双击controller文件打开Animator窗口

3. Layers设置:

   1. Mask: 比如这一层我们**只想表现手部持枪的动画**, 就对应创建一个只含arms的mask拖进来.
   2. Blending: 
      1. Override: 融合
      2. Addtive: 把当前动画加到上层layer中(例: **喘气**), 求上层layer必须有对应的curve, 否则无效. 因此**如果addtive无效果**, 可尝试调整层级排序和混合模式
   3. Sync: 同步跟进下面**Source Layer**的状态机结构
   4. IK Pass: 勾选以**激活IK功能**, 比如OnAnimatorIK(), Foot IK等

4. Parameters: 

   1. 添加状态参数, 用于控制状态机变换
   2. 有4种可选参数类型: float, int, bool, trigger

5. 状态机视图:

   1. **绿色Entry, 黄色初始态, 红色Exit**
   2. Auto Live Link: 聚集当前正在播放的动画状态

   

##### 02 [state设置](https://docs.unity.cn/cn/2022.1/Manual/class-State.html)

   1. Tag: 打标签
   2. Motion: animation clip 或 Blend Tree
   3. Speed: 大于1是回事, 小于0是倒放. Multiplier是开放给script的变速器
   4. MotionTime: 其实是process, 取值[0, 1], 通过设置关联变量可以精确控制播放motion的哪一部分
   5. Mirror: 左右镜像动画, 只对Humanoid动画起作用
   6. Cycle Offset: 循环动画(因此必须勾选clip的loop time) 从哪个位置开始播. 偏移并不是切割, **每一轮会播放完整**的动画循环
   7. Foot IK: 把foot的位置向IK Goal的位置拉近一点儿. 
         1. 只能略微调整foot的位置, 不见得能产生高质量的动画
         2. 调整IK Goal的位置并不会更改Foot IK的效果, 因为Foot IK默认参考的是IK Goal的初始位置而不是当前位置, 需要通过**SetIKPositionWeight()等方法调整weight**才可以
         3. 因为IK Goal仅用于humanoid动画, 因此Foot IK也仅对humanoid有效

   8. [Write Defaults](https://www.bilibili.com/video/BV1WL411c7mK): 
         1. 在animator执行OnEnable()方法时, 会遍历状态机控制所有属性. 
         2. 如果某个clip没有控制某个属性, 则当前clip将使用该属性的默认值. 
         3. 默认值在Animator执行OnEnable()的时候记录下来的, 每一个clip各自记录各自属性的默认值
         4. 如果**clip的当前属性跟默认值不同, 比如position, 则强制设置为postion默认值后, 可能会导致player发生奇怪的位移**
         5. 默认☑


```c#
// https://blog.csdn.net/rickshaozhiheng/article/details/77838379
// 在做pool功能的时候, 进pool之前重置一下动画的状态
animator.Crossfade("DefaultPose", 0f); //Force switch to Default Pose State, instant transition
animator.Update(0f); //force transition completion, your object should now be in default pose
go.SetActive(false); //disabled in default pose
```



##### 03 Transition设置

1. 支持两个状态之间的同一个方向上添加多个transitions, 这时表示transition的**连线箭头会变成松树**状. 这多个**转换的选择优先级**是:
   1. 如果有勾选了solo的转换, 则只从solos中选择, 不考虑其它的
   2. 所有solos中, 哪个转换条件先满足, 就先执行哪个转换
   3. 如果有多个solos同时满足条件, 则优先执行列表顺序上面的那个转换. 
   4. 在transition的inspector中, transitions列表的顺序不可调整, 但**在state的inspector中, transitions列表的顺序可以手拖调整**的
   5. 勾选了mute的转换永远不会执行
2. Has Exit Time: 
   1. 默认☑
   2. 在☑状态下, 前置**动画状态播放时间 >= Exit Time设置的时间百分比%**后就执行该转换
   3. 如果不勾选Has Exit Time, 则必须要在下面的Conditions列表中手动添加转换条件, 否则该转换永远不会执行(会有黄色报警)
3. Exit Time: **设置exit时间, 单位是百分比%**, 而不是s. 如果设置0.5, 意味着执行到动画50%的时候发生转换. 可以大于1
4. Fixed Duration: 控制下面的Transition Duration的**单位是%还是s**
5. Transition Offset: 进入下一个动画状态的偏移量, 单位是百分比%
6. [Interruption Source](https://www.bilibili.com/video/BV1xq4y147pD): 有哪些转换可以打断当前转换:
   1.  None: 当前转换不可被打断, 就像在途的飞机不能随意改变航向一样
   2. Current State: 从A→B的转换, 可以被**某些(Ordered Interruption)**同样从A出发的转换打断, 比如笑到一半的人突然变成愤怒
   3. Next State: 从A→B的转换, 可以被**任意(Ordered Interruption不可勾选)**从B出发的转换打断
   4. Ordered Interruption: 默认☑, 这意味着仅高优先级可以中断低优先级的转换. 优先级由state的inspector视图transitions列表的顺序确定, **越靠上的优先级别越高**
7. Conditions: 控制状态转换的触发条件 
   1. 多个转换条件之间是**逻辑与**的关系, conditions条件与Has Exit Time也是逻辑与的关系, 即必须同步满足才能执行
   2. 如果想设计**逻辑或**关系的转换条件, 可以考虑创建多个transitions
   3. trigger是一个信号, 如果当前无法触发转换的话会一直等待, **直到触发转换成功后, trigger信号被消费掉**.



#### 5 [Avatar替身](https://www.bilibili.com/video/BV1GL4y1B7s1)

##### 01 Basics

1. **替(复用)身(人形)**: 
2. 把模型的**骨骼信息**以及与unity标准肌肉之间的**mapping信息**存储在avatar文件中, 这时就不再需要模型上的骨骼信息了
3. AnimationClip需要严格匹配path才能播放动画, 但avatar自动寻找当前节点与子节点的, **层层寻找符合要求的模型并播放动画**



##### 02 fbx导入设置

1. 找到模型的fbx文件, 在inspector→Rig
   1. AnimationType→Humanoid
   2. Avatar Definition: 创建肌肉mapping关系
      1. **模型fbx+动画fbx→均可以选Create From This Model**
      2. **动画fbx也可以选Copy From Other Avatar**, 但需挑选一个跟本model结构一样的avatar, 以**Apply之后不报错为准**
      3. Animator组件中的Avatar**固定使用本模型创建的**avatar
      4. Configure: 如果从[mixamo](https://mixamo.com)网站下载动画时选择**No Skin, 则Avatar的T-Pose很可能不合格**, 这时需要手动调整参数
   3. Skin Weights: 一个skin节点受几个bones影响
   4. Optimize Game Objects: 建议选中, 使用avatar之后模型身上的骨骼信息已经无用了, 可以通过该选项删除掉, 可节约存储



#### 6 Animation Rigging

1. 目标: **简化动画制作流**程
2. 可完全代替内置IK, 因此不再需要OnAnimatorIK()回调, 不再需要在controller中启用IK Pass



#### 7 IK

##### 01 Basics

1. IK(Inverse Kinematics)一般使用CCD(Cyclic Coordinate Decent): 从末端向前层层影响并迭代. 相反FK(Forward Kinematics)则是从**根骨骼(hips)**层层正向影响
1. **必须选勾选**至少一个状态机layer中的 IK Pass, 才能**激活IK功能**, 比如OnAnimatorIK(), Foot IK等
2. IK Gobal: 在使用Humanoid动画时, Scene场景下, 会看到8个红球. unity把骨骼系统下手和脚的**正确位置保存在4个IKGoal**中
3. IK Hint: 手肘和膝盖处的红球, 则是IK Hint, 用于防止关节出现奇怪扭曲



```c#
// 要求AnimatorController中至少一个layer勾选IK Pass
private void OnAnimatorIK(int layerIndex) 
{
  // 调整IKGoal的位置: leftHandGoal是一个空gameObject, 可以在游戏中通过拖拽调节. https://www.bilibili.com/video/BV1zS4y1b7oK
  animator.SetIKPosition(AvatarIKGoal.LeftHand, leftHandGoal.position);
  animator.SetIKRotation(AvatarIKGoal.LeftHand, leftHandGoal.rotation);
  
  // 设置weight. 有时候动画手的位置很怪异, 则可以通过这个weight启用IK Goal从而调整动画的偏移
  animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, 1f);
  animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, 1f);
}
```

