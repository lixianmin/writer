

#### 1 Basics



#### 2 AnimationClip

##### 01 Basics

1. 外部导入, 或在unity3d中制作
2. **cmd+6**: 打开animation窗口录制动画, 新建动画会得到anim, controller, animator这一个完整的资源
3.  unity3d中的很多资源文件都是yaml文件, 含: unity, prefab, anim, controller等
4. .anim文件中的每一个curve字段中会**存储path信息**, 如果path匹配不上则无法控制对应的骨骼



##### 02 设置

1. Loop Time: 勾选 → 循环播放, 对于walk, run之类的动画是必选的



#### 3 Animator组件

##### 01 Basics



##### 02 设置

1. Controller: 挂载动画状态机(AnimatorController)
2. Avatar: 使用Humanoid动画时, 在这里挂载**自己创建的Avatar**. 同时只要Model位于Animator的子节点中即可, 对多少层无要求
3. Apply Root Motion: 使用**动画位移**, 而不是script控制位移(in place动画)
4. Update Mode更新模式:
   1. Normal: 与Update帧率同步
   2. Animate Physics: 与Fixed Update帧率同步, 适合碰撞交互, 适合手感要求高的act游戏
   3. Unscaled Time: 忽略timeScale设置, 动画不会随timeScale设置变快或变慢
5. Culing Mode剔除模式:
   1. Always Animate: 在camera看不见时也不剔除
   2. Cull Update Transforms: 在camera看不见时**剔除IK**
   3. Cull Completely: 在camera看不见时停止动画



```c#

var index = animator.GetLayoutIndex("Base Layer");
animator.SetLayerWeight(layer, 1);

// OnAnimatorMove()隶属physics逻辑, 可从root motion抢夺player控制权.
private void OnAnimatorMove()
{
  // script出现OnAnimatorMove(), 物体就由script而不是root motion控制移动了
  // 如果想应用root motion的效果, 可以自己调用ApplyBuiltinRootMotion(), 然后再微调transform的位置
  animator.ApplyBuiltinRootMotion();
  
  // characterController.Move(animator.deltaPosition); // Move()方法需要自己写gravity逻辑
  characterController.SimpleMove(animator.velocity);	 // SimpleMove()方法自带gravity逻辑
  
  // 设置状态转移条件
  animator.SetFloat("Speed", speed);
}

```





#### 4 AnimatorController状态机

1. **有限状态机**: 
   1. 10个以内clip文件可以考虑手建状态机
   2. 如果clip太多的话建议使用[AnimatorOverrideController](https://docs.unity.cn/cn/current/ScriptReference/AnimatorOverrideController.ApplyOverrides.html)动态加载clip, 然后直接使用`animator.Play("name");`播放
2. 双击controller文件打开Animator窗口
3. Layers设置:
   1. Mask: 比如这一层我们**只想表现手部持枪的动画**, 就对应创建一个只含arms的mask拖进来.
   2. Blending: 
      1. Override: 融合
      2. Addtive: 把当前动画加到上层layer中(例: **喘气**), 求上层layer必须有对应的curve, 否则无效. 因此**如果addtive无效果**, 可尝试调整层级排序和混合模式
   3. Sync: 同步跟进下面**Source Layer**的状态机结构
   4. IK Pass: 是否打开IK
4. Parameters: 添加状态参数, 用于控制状态机变换
5. 状态机视图:
   1. 绿色Entry, 黄色初始态, 红色Exit
   2. 



#### 5 [Avatar替身](https://www.bilibili.com/video/BV1GL4y1B7s1)

1. **替(复用)身(人形)**: 
2. 把模型的**骨骼信息**以及与unity标准肌肉之间的**mapping信息**存储在avatar文件中, 这时就不再需要模型上的骨骼信息了
3. AnimationClip需要严格匹配path才能播放动画, 但avatar自动寻找当前节点与子节点的, **层层寻找符合要求的模型并播放动画**
4. 找到模型的fbx文件, 在inspector→Rig
   1. AnimationType→Humanoid
   2. Avatar Definition: 创建肌肉mapping关系
      1. **模型fbx+动画fbx→均可以选Create From This Model**
      2. **动画fbx也可以选Copy From Other Avatar**, 但需挑选一个跟本model结构一样的avatar, 以**Apply之后不报错为准**
      3. Animator组件中的Avatar**固定使用本模型创建的**avatar
      4. Configure: 配置avatar细节
   3. Skin Weights: 一个skin节点受几个bones影响
   4. Optimize Game Objects: 建议选中, 使用avatar之后模型身上的骨骼信息已经无用了, 可以通过该选项删除掉, 可节约存储





#### 6 Animation Rigging

1. 目标: **简化动画制作流**程
2. 可完全代替内置IK, 因此不再需要OnAnimatorIK()回调, 不再需要在controller中启用IK Pass



#### 7 IK

##### 01 Basics

1. IK(Inverse Kinematics)一般使用CCD(Cyclic Coordinate Decent): 从末端向前层层影响并迭代. 相反FK(Forward Kinematics)则是从**根骨骼(hips)**层层正向影响
2. IK Gobal: 
3. IK Hint: 



```c#
// 要求AnimatorController中至少一个layer勾选IK Pass
private void OnAnimatorIK(int layerIndex) 
{
  // 调整IKGoal的位置: leftHandGoal是一个空gameObject, 可以在游戏中通过拖拽调节. https://www.bilibili.com/video/BV1zS4y1b7oK
  animator.SetIKPosition(AvatarIKGoal.LeftHand, leftHandGoal.position);
  animator.SetIKRotation(AvatarIKGoal.LeftHand, leftHandGoal.rotation);
  
  // 设置weight
  animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, 1f);
  animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, 1f);
}
```

