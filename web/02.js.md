

#### 01 Basics

##### 1 Basics

1. js的每一份元素都是看似跟其它语言一样，但特么的其实完全不一样
1. js与lua很像：
   1. 不是典型OO语言，而是基于原型链，js的prototype，lua的metatable
   2. js的[]与lua的table很像，都不是单纯的array或dict
2. 对象分类：
   1. 宿主对象：window, document
   2. 内置对象：数组[]，普通对象{}, 正则/abc/g
3. js中if(a)测试为false的值有：'', 0, null, false, undefined, nan；所以words=['', null, 'hello', undefined].filter(t=>t)的结果是['hello']
4. ==运算，因为试图转换类型后比较，所以被弃用。推荐程序员显示转换类型后，使用===比较
5. 不推荐使用with
6. class, closure, object是js中封装变量的三种方案



```js
// (推荐)使用class定义类，支持constructor和extends继承
class Rectangle {
  constructor(height, width) {
    this.height = height;	// 数据成员写在构造器中
    this.width = width;
  }
  get area() { // getter
    return this.calcArea();
  }
  calcArea() { // method
    return this.height * this.width;
  }
}

let c1 = new Rectangle(100, 200);
console.log(c1.area);

// object可以直接定义field
let c2 = {
  counter: 0,
  increment() {
    this.counter++;
    console.log(`${this.counter}`);
  }
}

c2.increment();

// (不推荐）function可以用closure
function Counter3() {
  let counter = 0;
  function increment() {
    counter++;
    console.log(`${counter}`);
  }
  
  return {increment};
}

let c3 = Counter3();
c3.increment();
```





##### 2 Promise

1. 宏任务: 
   1. MacroTask，由宿主发起，类似于windows消息事件循环，每个宏任务包含一个微任务队列

2. 微任务: 
   1. MicroTask，由js引擎发起。Promise永远在队列尾部添加微任务
   2. 宏任务→清空微任务队列→下一个宏任务→所有微任务→下一个宏任务

3. promise三种状态：pending, resolved, rejected
   1. 初始化pending状态，通过调用resolve方法转到resolved状态，通过调用reject转到rejected状态
4. 一个rejected状态的promise如果后面没有.catch，会导致全局错误
5. Promise类似于C#中的Task，配合async/await使用；对比unity3d用generator协程模拟异步的方案，Task/Promise显然异步到位



```js
function sleep(duration) {
    // resolve()或reject()都会改变promise的状态，因此只能执行一次
    return new Promise((resolve, reject) => {
        console.log("begin")
        if (duration <= 1000) {
            setTimeout(resolve, duration)
        } else {
            reject()
        }
    })
}

sleep(1000)
    .then(() => console.log("normal")) // resolve就是then中的方法，调用resolve
    .catch(() => console.log("catch")) // reject就是catch中的方法


// 执行顺序：a, b, c, d => 微任务一定等于宏任务执行完成
const r = new Promise(function(resolve, reject){
  console.log("a");
  resolve()
});
setTimeout(()=>console.log("d"), 0)
r.then(() => console.log("c"));
console.log("b")
```



```js
// 凡返回promise的方法，都隐含有一个async
function sleep(duration) {
    return new Promise((resolve) => {
        setTimeout(resolve, duration)
    })
}

// 组织异步任务
async function main() {
    await sleep(1000)
    await sleep(1000)
}

// main()方法需要使用.then()调用
main()
    .then(() => {
        process.exit(0)
    })
    .catch((err) => {
        console.error(err)
        process.exit(1)
    })
```





##### 3 Map

```js
let m = new Map();

// 这是增加对象属性的方法, 使用delete操作符删除
m.field1 = 1;
m["field2"] = 2;
delete m["field1"];

// 这是增加key值的方法，使用m.delete方法删除
m.set("key3", 3);
m.set("key4", 4);
m.delete("key3");

console.log(m); // output:  { 'key4' => 4, field2: 2 }
```



##### 4 function用作construct

```js
// Boolean, Number, String这些既可当function，也可当contruct
let a = Number("3"); 		// typeof a === 'number' 直接Number(any)表示强制类型转换，避免ParseInt()/ParseFloat()
let b = new Number(3); 	// typeof b === 'object' new表示创建object的

function f() {
  return 1;
}

let v = f(); 			// 把f作为函数调用，v=1, typeof v == number
let o = new f();	// 把f作为构造器调用，因为返回是简单值因此o={}, typeof o == object；如果返回对象{1:2}，则o就是对象


```



##### 5 var/let/const

1. var是函数执行的作用域，可穿透for, if语句
2. let是块级作用域，let替换了IIFE  (Immediate Invoke Function Evaluation)模式
3. const也是块级作用域，用const定义的对象，其指向无法变，但其属性可变，丢价于C#中readonly



```js
// 以下为IIFE模式变种，均可弃用
// void运算表示忽略后面表达式的值，变成undefined
void function(){
    var a;
    //code
}();

(function(){
    var a;
    //code
}());

(function(){
    var a;
    //code
})();


```



##### 6 this

1. 普通函数
   1. [普通函数就像纯函数，谁调用它this就指向谁](https://zhuanlan.zhihu.com/p/25349790)
   1. thisMode=global：表示当this为undefined时，取全局对象
   2. 普通函数可作为构造函数，但箭头函数不可以
2. 箭头函数
   1. 没有自己的this，函数内的this指向[定义该函数的外层作用域的this](https://zhuanlan.zhihu.com/p/57204184)
   2. thisMode=lexical：表示从上下文中找this
3. 方法
   1. 方法的行为跟普通函数有差异，恰恰是因为class设计成了默认按strict模式执行
   2. thisMode=strict：跟普通函数有些像，但this严格按照调用时传入的值，可能为null或undefined
4. call与apply
   1. Function.prototype.call 和 Function.prototype.apply 可以在函数调用时传入 this
   2. 这两个方法功能等价，只是传参方式不一样：appy这个单词更长，传参也比call更长（apply传数组，call直接传参数）




```js
///////////////////// 普通函数的this值是看运行时传入的是谁，如果不传就是global
function showThis(){
    console.log(this);
}

var o = {
    showThis: showThis
}

showThis(); 	// global
o.showThis(); // o

//////////////////// 箭头函数自己没有this值，就看外层作用域的this
const showThis = () => {
    console.log(this);
}

var o = {
    showThis: showThis
}

showThis(); // global
o.showThis(); // global

//////////////////// 方法的this值严格看运行时传入的是谁，如果不传就是undefined
class C {
    showThis() {
        console.log(this);
    }
}
var o = new C();
var showThis = o.showThis;

showThis(); // undefined
o.showThis(); // o

///////////////////// call与apply
function foo(a, b, c){
    console.log(this);
    console.log(a, b, c);
}
foo.call({}, 1, 2, 3);
foo.apply({}, [1, 2, 3]);
```





---

#### 09 References

1. [小心你复制的内容：使用零宽字符将用户名不可见的插入文本中](https://github.com/zengkan0703/text-watermark)
1. [浏览器数据库 IndexedDB 入门教程](https://www.ruanyifeng.com/blog/2018/07/indexeddb.html)
2. [Indexeded problems](https://gist.github.com/pesterhazy/4de96193af89a6dd5ce682ce2adff49a)
3. 