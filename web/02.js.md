

#### 01 Basics

##### 1 Basics

1. this指向：
   1. 普通函数的[this永远指向调用包含 自己（this本身）的函数对应的对象](https://zhuanlan.zhihu.com/p/25349790)；普通函数可作为构造函数，但箭头函数不可以
   2. 箭头函数没有自己的this，函数内的this指向[定义该函数时所在的作用域指向的对象](https://zhuanlan.zhihu.com/p/57204184)，而不是使用时所在的作用域指向的对象
2. js与lua很像：
   1. 不是典型OO语言，而是基于原型链，js的prototype，lua的metatable
   2. js的[]与lua的table很像，都不是单纯的array或dict

3. 对象分类：
   1. 宿主对象：window, document
   2. 内置对象：数组[]，普通对象{}, 正则/abc/g

4. js中if(a)测试为false的值有：'', 0, null, false, undefined, nan；所以words=['', null, 'hello', undefined].filter(t=>t)的结果是['hello']
5. var定义全局变量，类似于lua中的变量；let是正常块变量；const定义的对象，指向无法变，但其属性可变
6. ==运算，因为试图喹类型比较，所以被弃用。推荐程序员显示转换类型后，使用===比较
7. class, closure, object是js中封装变量的三种方案



```js
// (推荐)使用class定义类，支持constructor和extends继承
class Rectangle {
  constructor(height, width) {
    this.height = height;	// 数据成员写在构造器中
    this.width = width;
  }
  get area() { // getter
    return this.calcArea();
  }
  calcArea() { // method
    return this.height * this.width;
  }
}

let c1 = new Rectangle(100, 200);
console.log(c1.area);

// object可以直接定义field
let c2 = {
  counter: 0,
  increment() {
    this.counter++;
    console.log(`${this.counter}`);
  }
}

c2.increment();

// (不推荐）function可以用closure
function Counter3() {
  let counter = 0;
  function increment() {
    counter++;
    console.log(`${counter}`);
  }
  
  return {increment};
}

let c3 = Counter3();
c3.increment();
```





##### 2 Promise

1. 宏任务: MacroTask，由宿主发起，类似于windows消息事件循环，每个宏任务包含一个微任务队列
2. 微任务: MicroTask，由js引擎发起。Promise永远在队列尾部添加微任务
1. promise三种状态：pending, resolved, rejected
   1. 初始化pending状态，通过调用resolve方法转到resolved状态，通过调用reject转到rejected状态
4. 一个rejected状态的promise如果后面没有.catch，会导致全局错误



```js
function sleep(duration) {
    // resolve()或reject()都会改变promise的状态，因此只能执行一次
    return new Promise((resolve, reject) => {
        console.log("begin")
        if (duration <= 1000) {
            setTimeout(resolve, duration)
        } else {
            reject()
        }
    })
}

sleep(1000)
    .then(() => console.log("normal")) // resolve就是then中的方法，调用resolve
    .catch(() => console.log("catch")) // reject就是catch中的方法


// 执行顺序：a, b, c, d => 微任务一定等于宏任务执行完成
const r = new Promise(function(resolve, reject){
  console.log("a");
  resolve()
});
setTimeout(()=>console.log("d"), 0)
r.then(() => console.log("c"));
console.log("b")
```



##### 3 Map

```js
let m = new Map();

// 这是增加对象属性的方法, 使用delete操作符删除
m.field1 = 1;
m["field2"] = 2;
delete m["field1"];

// 这是增加key值的方法，使用m.delete方法删除
m.set("key3", 3);
m.set("key4", 4);
m.delete("key3");

console.log(m); // output:  { 'key4' => 4, field2: 2 }
```



##### 4 function用作construct

```js
// Boolean, Number, String这些既可当function，也可当contruct
let a = Number("3"); 		// typeof a === 'number' 直接Number(any)表示强制类型转换，避免ParseInt()/ParseFloat()
let b = new Number(3); 	// typeof b === 'object' new表示创建object的

function f() {
  return 1;
}

let v = f(); 			// 把f作为函数调用，v=1, typeof v == number
let o = new f();	// 把f作为构造器调用，因为返回是简单值因此o={}, typeof o == object；如果返回对象{1:2}，则o就是对象


```





---

#### 09 References

1. [浏览器数据库 IndexedDB 入门教程](https://www.ruanyifeng.com/blog/2018/07/indexeddb.html)
2. [Indexeded problems](https://gist.github.com/pesterhazy/4de96193af89a6dd5ce682ce2adff49a)
3. 