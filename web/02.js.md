

#### 01 Basics

##### 1 Basics

1. this指向：
   1. 普通函数的[this永远指向调用包含 自己（this本身）的函数对应的对象](https://zhuanlan.zhihu.com/p/25349790)；普通函数可作为构造函数，但箭头函数不可以
   2. 箭头函数没有自己的this，函数内的this指向[定义该函数时所在的作用域指向的对象](https://zhuanlan.zhihu.com/p/57204184)，而不是使用时所在的作用域指向的对象
2. js中if(a)测试为false的值有：'', 0, null, false, undefined, nan；所以words=['', null, 'hello', undefined].filter(t=>t)的结果是['hello']
3. var定义全局变量，类似于lua中的变量；let是正常块变量；const定义的对象，指向无法变，但其属性可变
4. ==运算，因为试图喹类型比较，所以被弃用。推荐程序员显示转换类型后，使用===比较
5. class, closure, object是js中封装变量的三种方案



```js
let a = Number("3"); 		// typeof a === 'number' 直接Number(any)表示强制类型转换，避免ParseInt()/ParseFloat()
let b = new Number(3); 	// typeof b === 'object' new表示创建object的


// class有field
class Counter1 {
  constructor() {
    this.counter = 0;
  }
  
  increment() {
    this.counter++;
    console.log(`${this.counter}`);
  }
}

let c1 = new Counter1();
c1.increment();

// function可以用closure
function Counter2() {
  let counter = 0;
  function increment() {
    counter++;
    console.log(`${counter}`);
  }
  
  return {increment};
}

let c2 = Counter2();
c2.increment();

// object可以直接定义field
let c3 = {
  counter: 0,
  increment() {
    this.counter++;
    console.log(`${this.counter}`);
  }
}

c3.increment();

```





##### 2 Promise

1. promise三种状态：pending, resolved, rejected
   1. 初始化pending状态，通过调用resolve方法转到resolved状态，通过调用reject转到rejected状态
2. resolved状态的promise会调用后面的第一个.then
3. rejected状态的promise会调用后面的第一个.catch
4. 任何一个rejected状态且后面没有.catch的promise，都会千万浏览器/node环境的全局错误



```js
(function() {
  var promise = new Promise(function (resolve, reject) {
    setTimeout(()=>{
      reject(new Error('1'));
    }, 300);
  }).catch((err)=>{
    //console.log(err);
  }).then((res)=> {
    console.log(res);
  })

  // console.log(promise);
  setTimeout(()=>{
    console.log(promise);
  }, 800);
})();
```





---

#### 09 References

1. [浏览器数据库 IndexedDB 入门教程](https://www.ruanyifeng.com/blog/2018/07/indexeddb.html)
2. [Indexeded problems](https://gist.github.com/pesterhazy/4de96193af89a6dd5ce682ce2adff49a)
3. 