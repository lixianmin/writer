

----

#### 01 ACID

1. A目标C酱油I并发D吹牛,

2. 原子性: 必须通过undo或redo才能实现, Redis的 (multi, exec, discard, watch)并不支持回滚, lua script也不支持回滚, 所以默认是无法实现atomicity的. 

   不过, Redis的isolation是可串行化的, 这意味着如果使用lua script修改数据, 那么如果在执行过程中发现执行不下去, 则必然可以手动恢复被修改的数据. 这个方案在RC等isolation级别中做不到. 所以, **精心设计了回滚策略的代码可以支持原子性**.

3. 一致性: 无讨论意义

4. 隔离性: 一直是serializability, 最强事务一致性

5. Durability持久性: redis提供rdb与aof机制, 通过配置appendfsync可以提供与MySQL相仿的单机持久性; 

   但redis的主从机制不够完善, 无法提供一主二从三副本等价的配置. 即使它提供了wait指令, 但一方面这需要代码主动调用, 太麻烦. 另一方面, wait指令可能会超时, 此时主节点的数据已经修改, 但从节点不见得会完成数据修改. 此时自动切主的话, 数据可能会丢失.

   但是, 需要看到, 即使MySQL的数据, 有时候也是需要回滚到1天以前的数据, 最重要的是保持DB中数据的一致性. 因此, 我们可以整体上认为Redis的持久性保证是基本可靠的.



---

#### 02 Distributed Lock

1. 因为NPC问题不可解, 导致Redis锁无法提供完整的fencing token实现,
2. fencing token要素: 
   1. 绝对单调递增的id: redis在切主可能会回滚, MySQL的autoincrement也不靠谱
   2. fencing token要参与落盘计算, 通过比较大小决定是否是当前的leader

3. 所以, 是否使用redis锁的关键考量是: 性能 vs. 完整性. 如果是为了防止大部分情况下的重复计算问题, 可以使用redis锁, 否则请转岗zk或etcd



#### 03 Redis非缓存场景

1. 缓存是redis的典型应用场景, 它背后的支持逻辑是: 高速, 贵&小
2. 基于前面对redis支持ACID的分析, 我们认为它在数据一致性方面是可靠的, 那么基本结论就是**在非金融性业务中做主库是可以的**, 但有一些配套建议 
3. redis并不适合做数据分析, 这一点不如MySQL, MySQL至少在从库上抗一抗
4. 内存很贵: **要么是统计类业务, 要么考虑LRU过期问题**, 否则成本抗不住
5. 因为redis的主从同步支持较差, 因此基于aof的CDC方案可能有问题. 但返过来, 即使是前置kafka的方案, 也不能完全确保Redis与其它DB的数据是一致的. 
6. 反过来讲, 存储在redis中的数据要么只用于展示, 要么像counter一样参与计算但错一点儿其实无所谓. 我们要认识到, **redis只是多级分流系统中的一环**, 即使后端做到redis与MySQL中的数据实时同步, 也无法解决web端缓存的问题
7. 因此, 对于所有非金融类的, 可允许随时回滚, 差错一点儿无所谓的系统, 使用redis做主库都是可以接受的. 比如: cache, session, counter, rate limiter, shopping cart, user retention(留存), rank/leaderboard(排行榜). 这些功能的共同特点是: 
   1. **跟用户1比1的**: 只能作为MySQL的缓存, 随便过期
   2. **跟单个用户无关的统计类数据**: 不会随着用户量增加占用更多的内存
8. 内存小, 价格贵, 速度快, 不稳定. 所有redis的用法, 都必须以这几个特点为中心执行
8. 不建议将数据只放在Redis中, 因此建议前置放kafka或后置CDC, 至少把数据同步到MySQL中一份, 这样**有历史可查, 同时存储会便宜**



---

#### 09 References

1. [Redis命令参考：事务](http://redisdoc.com/topic/transaction.html)
2. [Redis 设计与实现（第一版）](https://redisbook.readthedocs.io/en/latest/index.html)
3. 